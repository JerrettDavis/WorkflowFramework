@inject IJSRuntime JS
@inject DashboardApiClient Api
@inject ToastService Toast
@inject KeyboardShortcutService Shortcuts
@implements IAsyncDisposable

<div class="flex flex-col h-full">
    <WorkflowToolbar WorkflowName="@_workflowName"
                     OnWorkflowNameChanged="name => { _workflowName = name; _dirty = true; }"
                     IsDirty="_dirty"
                     OnNew="HandleNew"
                     OnOpen="() => _showOpenDialog = true"
                     OnSave="HandleSave"
                     OnRun="HandleRun"
                     OnExportJson="HandleExportJson"
                     OnExportYaml="HandleExportYaml"
                     OnImportFile="HandleImport"
                     OnFitView="HandleFitView"
                     OnTemplates="() => _showTemplateBrowser = true"
                     OnValidate="HandleValidate"
                     ValidationErrorCount="ValidationErrorCount"
                     OnSettings="() => _showSettings = true"
                     OnShortcutsHelp="() => _showShortcutsHelp = true" />

    <div class="flex flex-1 overflow-hidden">
        <StepPalette />

        <div class="flex-1 relative" id="workflow-canvas"></div>

        <PropertiesPanel SelectedNodeId="@_selectedNodeId"
                         SelectedNodeType="@_selectedNodeType"
                         NodeConfig="_selectedNodeConfig"
                         OnConfigChanged="HandleConfigChanged" />
    </div>

    <ValidationPanel ValidationErrors="_validationErrors"
                     OnErrorClicked="HandleValidationErrorClicked" />

    <ExecutionPanel IsVisible="_showExecutionPanel"
                    OnToggle="() => _showExecutionPanel = !_showExecutionPanel"
                    LogEntries="_logEntries"
                    ActiveRunId="@_activeRunId"
                    OnRunStatusChanged="HandleRunStatusChanged"
                    OnStepStatusChanged="HandleStepStatusChanged" />
</div>

<TemplateBrowser IsVisible="_showTemplateBrowser"
                 OnClose="() => _showTemplateBrowser = false"
                 OnTemplateUsed="HandleTemplateUsed" />

<WorkflowListDialog IsVisible="_showOpenDialog"
                    OnClose="() => _showOpenDialog = false"
                    OnWorkflowSelected="HandleWorkflowOpened" />

<ShortcutsHelp IsVisible="_showShortcutsHelp"
               OnClose="() => _showShortcutsHelp = false" />

<ToastContainer />

@code {
    private bool _showShortcutsHelp;
    private bool _showSettings;
    private DotNetObjectReference<WorkflowDesigner>? _dotNetRef;
    private string _workflowName = "Untitled Workflow";
    private string? _currentWorkflowId;
    private bool _dirty;
    private string? _selectedNodeId;
    private string? _selectedNodeType;
    private Dictionary<string, object?> _selectedNodeConfig = new();
    private bool _showExecutionPanel;
    private List<string> _logEntries = [];
    private bool _showTemplateBrowser;
    private bool _showOpenDialog;
    private string? _activeRunId;
    private List<ValidationErrorDto> _validationErrors = [];

    private int ValidationErrorCount => _validationErrors.Count(e => e.Severity == "Error");

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("workflowEditor.initialize", "workflow-canvas", _dotNetRef, Array.Empty<object>(), Array.Empty<object>());

            // Initialize keyboard shortcuts
            Shortcuts.Register("Ctrl+S", HandleSave);
            Shortcuts.Register("Ctrl+N", HandleNew);
            Shortcuts.Register("Ctrl+O", () => { _showOpenDialog = true; StateHasChanged(); return Task.CompletedTask; });
            Shortcuts.Register("Ctrl+Enter", HandleRun);
            Shortcuts.Register("Escape", () => { _showShortcutsHelp = false; _showOpenDialog = false; _showTemplateBrowser = false; _showSettings = false; _selectedNodeId = null; StateHasChanged(); return Task.CompletedTask; });
            Shortcuts.Register("Delete", () => JS.InvokeVoidAsync("workflowEditor.deleteSelected").AsTask());
            Shortcuts.Register("Backspace", () => JS.InvokeVoidAsync("workflowEditor.deleteSelected").AsTask());
            Shortcuts.OnShowHelp += () => { _showShortcutsHelp = true; InvokeAsync(StateHasChanged); return Task.CompletedTask; };
            await Shortcuts.InitializeAsync();
        }
    }

    [JSInvokable]
    public void OnNodeSelected(string? nodeId, string? nodeType, Dictionary<string, object?>? config)
    {
        _selectedNodeId = nodeId;
        _selectedNodeType = nodeType;
        _selectedNodeConfig = config ?? new();
        StateHasChanged();
    }

    [JSInvokable]
    public void OnNodeAdded(string nodeId, string nodeType, double x, double y)
    {
        _dirty = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnNodeRemoved(string nodeId)
    {
        if (_selectedNodeId == nodeId) { _selectedNodeId = null; _selectedNodeType = null; }
        _dirty = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnEdgeCreated(string sourceId, string targetId) { _dirty = true; StateHasChanged(); }

    [JSInvokable]
    public void OnEdgeRemoved(string edgeId) { _dirty = true; StateHasChanged(); }

    [JSInvokable]
    public void OnCanvasChanged() { _dirty = true; StateHasChanged(); }

    private async Task HandleNew()
    {
        _workflowName = "Untitled Workflow";
        _currentWorkflowId = null;
        _dirty = false;
        _selectedNodeId = null;
        _selectedNodeType = null;
        _activeRunId = null;
        await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", Array.Empty<object>(), Array.Empty<object>());
    }

    private async Task HandleSave()
    {
        try
        {
            var definition = await JS.InvokeAsync<System.Text.Json.JsonElement>("workflowEditor.getWorkflowDefinition");
            var request = new CreateWorkflowRequest
            {
                Description = null,
                Definition = new WorkflowDefinitionDto { Name = _workflowName }
            };

            SavedWorkflowDefinition? result;
            if (_currentWorkflowId is not null)
                result = await Api.UpdateWorkflowAsync(_currentWorkflowId, request);
            else
                result = await Api.SaveWorkflowAsync(request);

            if (result is not null)
            {
                _currentWorkflowId = result.Id;
                _dirty = false;
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Saved workflow: {_workflowName} (id: {result.Id})");
                Toast.Success($"Saved '{_workflowName}'");
            }
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Save failed: {ex.Message}");
            Toast.Error($"Save failed: {ex.Message}");
        }
    }

    private async Task HandleValidate()
    {
        try
        {
            if (_currentWorkflowId is not null)
            {
                var result = await Api.ValidateWorkflowAsync(_currentWorkflowId);
                _validationErrors = result?.Errors ?? [];
            }
            else
            {
                var definition = new WorkflowDefinitionDto { Name = _workflowName };
                var result = await Api.ValidateDefinitionAsync(definition);
                _validationErrors = result?.Errors ?? [];
            }

            if (_validationErrors.Count == 0)
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] ✅ Validation passed");
            else
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Validation: {_validationErrors.Count(e => e.Severity == "Error")} error(s), {_validationErrors.Count(e => e.Severity == "Warning")} warning(s)");
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Validation failed: {ex.Message}");
        }
    }

    private async Task HandleValidationErrorClicked(string? stepName)
    {
        if (stepName is not null)
        {
            await JS.InvokeVoidAsync("workflowEditor.selectNodeByName", stepName);
        }
    }

    private async Task HandleRun()
    {
        _showExecutionPanel = true;

        // Validate before running
        await HandleValidate();
        if (_validationErrors.Any(e => e.Severity == "Error"))
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] ❌ Cannot run: fix validation errors first");
            return;
        }

        if (_currentWorkflowId is null)
        {
            // Auto-save first
            await HandleSave();
            if (_currentWorkflowId is null)
            {
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Cannot run: workflow not saved");
                return;
            }
        }

        try
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Running workflow: {_workflowName}...");
            var run = await Api.RunWorkflowAsync(_currentWorkflowId);
            if (run is not null)
            {
                _activeRunId = run.RunId;
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run started: {run.RunId} (status: {run.Status})");
                Toast.Info($"Run started: {run.RunId}");
            }
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run failed: {ex.Message}");
            Toast.Error($"Run failed: {ex.Message}");
        }
    }

    private async Task HandleExportJson()
    {
        var definition = await JS.InvokeAsync<object>("workflowEditor.getWorkflowDefinition");
        var json = System.Text.Json.JsonSerializer.Serialize(definition, new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", json);
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] JSON copied to clipboard");
    }

    private async Task HandleExportYaml()
    {
        var definition = await JS.InvokeAsync<object>("workflowEditor.getWorkflowDefinition");
        var json = System.Text.Json.JsonSerializer.Serialize(definition);
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", json);
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Exported (JSON format - YAML requires server-side serializer)");
    }

    private async Task HandleImport(InputFileChangeEventArgs e)
    {
        try
        {
            using var stream = e.File.OpenReadStream(maxAllowedSize: 1024 * 1024);
            using var reader = new StreamReader(stream);
            var content = await reader.ReadToEndAsync();
            var parsed = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(content);

            if (parsed.TryGetProperty("nodes", out var nodes) && parsed.TryGetProperty("edges", out var edges))
            {
                await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", nodes, edges);
                _dirty = true;
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Imported workflow from {e.File.Name}");
            }
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Import failed: {ex.Message}");
        }
    }

    private async Task HandleFitView()
    {
        await JS.InvokeVoidAsync("workflowEditor.fitView");
    }

    private async Task HandleConfigChanged(Dictionary<string, object?> config)
    {
        _selectedNodeConfig = config;
        _dirty = true;
        if (_selectedNodeId is not null)
        {
            await JS.InvokeVoidAsync("workflowEditor.updateNode", _selectedNodeId, config);
        }
    }

    private async Task HandleTemplateUsed(SavedWorkflowDefinition saved)
    {
        _currentWorkflowId = saved.Id;
        _workflowName = saved.Definition.Name;
        _dirty = false;
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Loaded template as workflow: {_workflowName}");
        // Load the workflow definition into canvas - template creates a new workflow
        // For now just reset canvas; the nodes from template would need to be mapped to canvas format
        await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", Array.Empty<object>(), Array.Empty<object>());
    }

    private async Task HandleWorkflowOpened(SavedWorkflowDefinition saved)
    {
        _currentWorkflowId = saved.Id;
        _workflowName = saved.Definition.Name;
        _dirty = false;
        _selectedNodeId = null;
        _selectedNodeType = null;
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Opened workflow: {_workflowName}");
        await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", Array.Empty<object>(), Array.Empty<object>());
    }

    private async Task HandleStepStatusChanged((string StepName, string Status) stepStatus)
    {
        try
        {
            await JS.InvokeVoidAsync("workflowEditor.updateNodeStatus", stepStatus.StepName, stepStatus.Status);
        }
        catch { /* JS interop may fail if canvas not ready */ }
    }

    private void HandleRunStatusChanged(string status)
    {
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run status: {status}");
        if (status is "Completed" or "Failed" or "Cancelled")
        {
            _activeRunId = null;
        }
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        _dotNetRef?.Dispose();
        try { await Shortcuts.DisposeAsync(); } catch { }
        try { await JS.InvokeVoidAsync("workflowEditor.destroy"); } catch { }
    }
}
