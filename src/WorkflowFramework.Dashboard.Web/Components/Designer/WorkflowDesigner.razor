@inject IJSRuntime JS
@inject DashboardApiClient Api
@inject ToastService Toast
@inject KeyboardShortcutService Shortcuts
@implements IAsyncDisposable

<div class="flex flex-col h-full">
    <WorkflowToolbar WorkflowName="@_workflowName"
                     OnWorkflowNameChanged="name => { _workflowName = name; _dirty = true; }"
                     IsDirty="_dirty"
                     OnNew="HandleNew"
                     OnOpen="() => _showOpenDialog = true"
                     OnSave="HandleSave"
                     OnRun="HandleRun"
                     OnExportJson="HandleExportJson"
                     OnExportYaml="HandleExportYaml"
                     OnImportFile="HandleImport"
                     OnFitView="HandleFitView"
                     OnTemplates="() => _showTemplateBrowser = true"
                     OnValidate="HandleValidate"
                     ValidationErrorCount="ValidationErrorCount"
                     OnSettings="() => _showSettings = true"
                     OnShortcutsHelp="() => _showShortcutsHelp = true" />

    <div class="flex flex-1 overflow-hidden">
        <StepPalette />

        <div class="flex-1 relative" id="workflow-canvas"></div>

        <PropertiesPanel SelectedNodeId="@_selectedNodeId"
                         SelectedNodeType="@_selectedNodeType"
                         NodeConfig="_selectedNodeConfig"
                         OnConfigChanged="HandleConfigChanged"
                         Connections="_selectedNodeConnections"
                         OnConnectionClicked="HandleFocusNode" />
    </div>

    @* Tabbed bottom panels *@
    <div class="border-t border-gray-700 bg-gray-800" data-testid="bottom-tabs">
        <div class="flex items-center border-b border-gray-700">
            <button @onclick='() => _activeBottomTab = "output"'
                    class="px-4 py-1.5 text-xs @(_activeBottomTab == "output" ? "text-blue-400 border-b-2 border-blue-400 bg-gray-850" : "text-gray-400 hover:text-gray-200")"
                    data-testid="tab-output">
                Output
                @if (_activeRunId is not null)
                {
                    <span class="ml-1 text-yellow-400">‚óè</span>
                }
            </button>
            <button @onclick='() => { _activeBottomTab = "steps"; RefreshStepList(); }'
                    class="px-4 py-1.5 text-xs @(_activeBottomTab == "steps" ? "text-blue-400 border-b-2 border-blue-400 bg-gray-850" : "text-gray-400 hover:text-gray-200")"
                    data-testid="tab-steps">
                Steps
            </button>
            <button @onclick='() => _activeBottomTab = "validation"'
                    class="px-4 py-1.5 text-xs @(_activeBottomTab == "validation" ? "text-blue-400 border-b-2 border-blue-400 bg-gray-850" : "text-gray-400 hover:text-gray-200")"
                    data-testid="tab-validation">
                Validation
                @if (_validationErrors.Count > 0)
                {
                    <span class="ml-1 px-1.5 py-0.5 rounded-full text-[10px] bg-red-500/20 text-red-400">@ValidationErrorCount</span>
                }
            </button>
            <div class="flex-1"></div>
            <button @onclick="() => _bottomPanelCollapsed = !_bottomPanelCollapsed"
                    class="px-3 py-1.5 text-xs text-gray-500 hover:text-gray-300"
                    data-testid="toggle-bottom-panel">
                @(_bottomPanelCollapsed ? "‚ñ≤" : "‚ñº")
            </button>
        </div>

        @if (!_bottomPanelCollapsed)
        {
            <div class="h-40">
                @if (_activeBottomTab == "output")
                {
                    <div class="h-full overflow-y-auto p-3 bg-gray-900 font-mono text-xs text-gray-300" data-testid="output-content">
                        @if (_logEntries.Count == 0)
                        {
                            <p class="text-gray-600">No output yet. Run a workflow to see results.</p>
                        }
                        else
                        {
                            @foreach (var entry in _logEntries)
                            {
                                <div class="py-0.5 @GetLogClass(entry)">@entry</div>
                            }
                        }
                    </div>
                }
                else if (_activeBottomTab == "steps")
                {
                    <StepListPanel @ref="_stepListPanel"
                                   SelectedNodeId="@_selectedNodeId"
                                   OnNodeClicked="HandleFocusNode" />
                }
                else if (_activeBottomTab == "validation")
                {
                    <div class="h-full overflow-y-auto bg-gray-900" data-testid="validation-content">
                        @if (_validationErrors.Count == 0)
                        {
                            <div class="p-3 text-gray-600 text-xs">No validation errors. Click Validate to check.</div>
                        }
                        else
                        {
                            @foreach (var error in _validationErrors)
                            {
                                <button @onclick="() => HandleValidationErrorClicked(error.StepName)"
                                        class="w-full flex items-center gap-2 px-3 py-1 text-xs hover:bg-gray-700 text-left">
                                    <span class="@GetSeverityClass(error.Severity)">@GetSeverityIcon(error.Severity)</span>
                                    @if (error.StepName is not null)
                                    {
                                        <span class="text-blue-400 font-mono">@error.StepName</span>
                                    }
                                    <span class="text-gray-300">@error.Message</span>
                                </button>
                            }
                        }
                    </div>
                }
            </div>
        }
    </div>
</div>

<TemplateBrowser IsVisible="_showTemplateBrowser"
                 OnClose="() => _showTemplateBrowser = false"
                 OnTemplateUsed="HandleTemplateUsed" />

<WorkflowListDialog IsVisible="_showOpenDialog"
                    OnClose="() => _showOpenDialog = false"
                    OnWorkflowSelected="HandleWorkflowOpened" />

<ShortcutsHelp IsVisible="_showShortcutsHelp"
               OnClose="() => _showShortcutsHelp = false" />

<ToastContainer />

@code {
    private bool _showShortcutsHelp;
    private bool _showSettings;
    private DotNetObjectReference<WorkflowDesigner>? _dotNetRef;
    private string _workflowName = "Untitled Workflow";
    private string? _currentWorkflowId;
    private bool _dirty;
    private string? _selectedNodeId;
    private string? _selectedNodeType;
    private Dictionary<string, object?> _selectedNodeConfig = new();
    private PropertiesPanel.NodeConnections? _selectedNodeConnections;
    private bool _showTemplateBrowser;
    private bool _showOpenDialog;
    private string? _activeRunId;
    private List<ValidationErrorDto> _validationErrors = [];
    private List<string> _logEntries = [];
    private string _activeBottomTab = "output";
    private bool _bottomPanelCollapsed;
    private StepListPanel? _stepListPanel;

    private int ValidationErrorCount => _validationErrors.Count(e => e.Severity == "Error");

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("workflowEditor.initialize", "workflow-canvas", _dotNetRef, Array.Empty<object>(), Array.Empty<object>());

            Shortcuts.Register("Ctrl+S", HandleSave);
            Shortcuts.Register("Ctrl+N", HandleNew);
            Shortcuts.Register("Ctrl+O", () => { _showOpenDialog = true; StateHasChanged(); return Task.CompletedTask; });
            Shortcuts.Register("Ctrl+Enter", HandleRun);
            Shortcuts.Register("Escape", () => { _showShortcutsHelp = false; _showOpenDialog = false; _showTemplateBrowser = false; _showSettings = false; _selectedNodeId = null; StateHasChanged(); return Task.CompletedTask; });
            Shortcuts.Register("Delete", () => JS.InvokeVoidAsync("workflowEditor.deleteSelected").AsTask());
            Shortcuts.Register("Backspace", () => JS.InvokeVoidAsync("workflowEditor.deleteSelected").AsTask());
            Shortcuts.OnShowHelp += () => { _showShortcutsHelp = true; InvokeAsync(StateHasChanged); return Task.CompletedTask; };
            await Shortcuts.InitializeAsync();
        }
    }

    [JSInvokable]
    public async void OnNodeSelected(string? nodeId, string? nodeType, Dictionary<string, object?>? config)
    {
        _selectedNodeId = nodeId;
        _selectedNodeType = nodeType;
        _selectedNodeConfig = config ?? new();

        if (nodeId is not null)
        {
            try
            {
                var connData = await JS.InvokeAsync<System.Text.Json.JsonElement>("workflowEditor.getNodeConnections", nodeId);
                _selectedNodeConnections = new PropertiesPanel.NodeConnections();
                if (connData.TryGetProperty("inputs", out var inputs))
                {
                    foreach (var item in inputs.EnumerateArray())
                    {
                        _selectedNodeConnections.Inputs.Add(new PropertiesPanel.ConnectionInfo
                        {
                            Id = item.GetProperty("id").GetString() ?? "",
                            Label = item.GetProperty("label").GetString() ?? "",
                            EdgeLabel = item.TryGetProperty("edgeLabel", out var el) && el.ValueKind != System.Text.Json.JsonValueKind.Null ? el.GetString() : null
                        });
                    }
                }
                if (connData.TryGetProperty("outputs", out var outputs))
                {
                    foreach (var item in outputs.EnumerateArray())
                    {
                        _selectedNodeConnections.Outputs.Add(new PropertiesPanel.ConnectionInfo
                        {
                            Id = item.GetProperty("id").GetString() ?? "",
                            Label = item.GetProperty("label").GetString() ?? "",
                            EdgeLabel = item.TryGetProperty("edgeLabel", out var el) && el.ValueKind != System.Text.Json.JsonValueKind.Null ? el.GetString() : null
                        });
                    }
                }
            }
            catch { _selectedNodeConnections = null; }
        }
        else
        {
            _selectedNodeConnections = null;
        }

        StateHasChanged();
    }

    [JSInvokable]
    public void OnNodeAdded(string nodeId, string nodeType, double x, double y)
    {
        _dirty = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnNodeRemoved(string nodeId)
    {
        if (_selectedNodeId == nodeId) { _selectedNodeId = null; _selectedNodeType = null; _selectedNodeConnections = null; }
        _dirty = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnEdgeCreated(string sourceId, string targetId) { _dirty = true; StateHasChanged(); }

    [JSInvokable]
    public void OnEdgeRemoved(string edgeId) { _dirty = true; StateHasChanged(); }

    [JSInvokable]
    public void OnCanvasChanged() { _dirty = true; StateHasChanged(); }

    private async Task HandleFocusNode(string nodeId)
    {
        await JS.InvokeVoidAsync("workflowEditor.focusNode", nodeId);
    }

    private async void RefreshStepList()
    {
        if (_stepListPanel is not null)
        {
            await Task.Yield(); // let render complete
            await _stepListPanel.RefreshAsync();
        }
    }

    private async Task HandleNew()
    {
        _workflowName = "Untitled Workflow";
        _currentWorkflowId = null;
        _dirty = false;
        _selectedNodeId = null;
        _selectedNodeType = null;
        _selectedNodeConnections = null;
        _activeRunId = null;
        await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", Array.Empty<object>(), Array.Empty<object>());
    }

    private async Task HandleSave()
    {
        try
        {
            var definition = await JS.InvokeAsync<System.Text.Json.JsonElement>("workflowEditor.getWorkflowDefinition");
            var request = new CreateWorkflowRequest
            {
                Description = null,
                Definition = new WorkflowDefinitionDto { Name = _workflowName }
            };

            SavedWorkflowDefinition? result;
            if (_currentWorkflowId is not null)
                result = await Api.UpdateWorkflowAsync(_currentWorkflowId, request);
            else
                result = await Api.SaveWorkflowAsync(request);

            if (result is not null)
            {
                _currentWorkflowId = result.Id;
                _dirty = false;
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Saved workflow: {_workflowName} (id: {result.Id})");
                Toast.Success($"Saved '{_workflowName}'");
            }
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Save failed: {ex.Message}");
            Toast.Error($"Save failed: {ex.Message}");
        }
    }

    private async Task HandleValidate()
    {
        try
        {
            if (_currentWorkflowId is not null)
            {
                var result = await Api.ValidateWorkflowAsync(_currentWorkflowId);
                _validationErrors = result?.Errors ?? [];
            }
            else
            {
                var definition = new WorkflowDefinitionDto { Name = _workflowName };
                var result = await Api.ValidateDefinitionAsync(definition);
                _validationErrors = result?.Errors ?? [];
            }

            if (_validationErrors.Count == 0)
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] ‚úÖ Validation passed");
            else
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Validation: {_validationErrors.Count(e => e.Severity == "Error")} error(s), {_validationErrors.Count(e => e.Severity == "Warning")} warning(s)");
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Validation failed: {ex.Message}");
        }
    }

    private async Task HandleValidationErrorClicked(string? stepName)
    {
        if (stepName is not null)
        {
            await JS.InvokeVoidAsync("workflowEditor.selectNodeByName", stepName);
        }
    }

    private async Task HandleRun()
    {
        _activeBottomTab = "output";
        _bottomPanelCollapsed = false;

        await HandleValidate();
        if (_validationErrors.Any(e => e.Severity == "Error"))
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] ‚ùå Cannot run: fix validation errors first");
            return;
        }

        if (_currentWorkflowId is null)
        {
            await HandleSave();
            if (_currentWorkflowId is null)
            {
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Cannot run: workflow not saved");
                return;
            }
        }

        try
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Running workflow: {_workflowName}...");
            var run = await Api.RunWorkflowAsync(_currentWorkflowId);
            if (run is not null)
            {
                _activeRunId = run.RunId;
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run started: {run.RunId} (status: {run.Status})");
                Toast.Info($"Run started: {run.RunId}");
            }
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run failed: {ex.Message}");
            Toast.Error($"Run failed: {ex.Message}");
        }
    }

    private async Task HandleExportJson()
    {
        var definition = await JS.InvokeAsync<object>("workflowEditor.getWorkflowDefinition");
        var json = System.Text.Json.JsonSerializer.Serialize(definition, new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", json);
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] JSON copied to clipboard");
    }

    private async Task HandleExportYaml()
    {
        var definition = await JS.InvokeAsync<object>("workflowEditor.getWorkflowDefinition");
        var json = System.Text.Json.JsonSerializer.Serialize(definition);
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", json);
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Exported (JSON format - YAML requires server-side serializer)");
    }

    private async Task HandleImport(InputFileChangeEventArgs e)
    {
        try
        {
            using var stream = e.File.OpenReadStream(maxAllowedSize: 1024 * 1024);
            using var reader = new StreamReader(stream);
            var content = await reader.ReadToEndAsync();
            var parsed = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(content);

            if (parsed.TryGetProperty("nodes", out var nodes) && parsed.TryGetProperty("edges", out var edges))
            {
                await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", nodes, edges);
                _dirty = true;
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Imported workflow from {e.File.Name}");
            }
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Import failed: {ex.Message}");
        }
    }

    private async Task HandleFitView()
    {
        await JS.InvokeVoidAsync("workflowEditor.fitView");
    }

    private async Task HandleConfigChanged(Dictionary<string, object?> config)
    {
        _selectedNodeConfig = config;
        _dirty = true;
        if (_selectedNodeId is not null)
        {
            await JS.InvokeVoidAsync("workflowEditor.updateNode", _selectedNodeId, config);
        }
    }

    private async Task HandleTemplateUsed(SavedWorkflowDefinition saved)
    {
        _currentWorkflowId = saved.Id;
        _workflowName = saved.Definition.Name;
        _dirty = false;
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Loaded template as workflow: {_workflowName}");
        await LoadDefinitionIntoCanvas(saved.Definition);
    }

    private async Task HandleWorkflowOpened(SavedWorkflowDefinition saved)
    {
        _currentWorkflowId = saved.Id;
        _workflowName = saved.Definition.Name;
        _dirty = false;
        _selectedNodeId = null;
        _selectedNodeType = null;
        _selectedNodeConnections = null;
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Opened workflow: {_workflowName}");
        await LoadDefinitionIntoCanvas(saved.Definition);
    }

    private async Task LoadDefinitionIntoCanvas(WorkflowDefinitionDto definition)
    {
        var nodes = new List<object>();
        var edges = new List<object>();
        int nodeCounter = 0;
        
        string NextId() => $"node_{++nodeCounter}";

        static (string category, string color, string icon) GetStepVisuals(string type) => type.ToLowerInvariant() switch
        {
            "action" => ("Core", "#3b82f6", "‚¨°"),
            "conditional" => ("Core", "#3b82f6", "‚óá"),
            "parallel" => ("Core", "#3b82f6", "‚´ò"),
            "foreach" or "while" or "dowhile" => ("Core", "#3b82f6", "‚Üª"),
            "retry" => ("Core", "#3b82f6", "üîÑ"),
            "trycatch" => ("Core", "#3b82f6", "üõ°"),
            "timeout" => ("Core", "#3b82f6", "‚è±"),
            "delay" => ("Core", "#3b82f6", "‚è±"),
            "saga" => ("Core", "#3b82f6", "üìú"),
            "contentbasedrouter" or "messagefilter" or "splitter" or "aggregator" 
                or "recipientlist" or "wiretap" or "deadletterchannel" or "enricher" 
                or "normalizer" or "claimcheck" or "dynamicrouter" or "routingslip"
                => ("Integration", "#22c55e", "üîÄ"),
            "httpstep" => ("HTTP", "#14b8a6", "üåê"),
            "llmcallstep" or "agentdecisionstep" => ("AI/Agents", "#a855f7", "ü§ñ"),
            "agentloopstep" or "toolcallstep" => ("AI/Agents", "#a855f7", "üß†"),
            "datamapstep" or "validatestep" or "schemavalidatestep" => ("Data", "#f97316", "üó∫"),
            "publisheventstep" or "subscribeeventstep" => ("Events", "#eab308", "‚ö°"),
            "humantaskstep" or "approvalstep" => ("Human Tasks", "#ec4899", "‚úÖ"),
            _ => ("Core", "#3b82f6", "‚¨°")
        };

        int edgeCounter = 0;
        void AddEdge(string source, string target, string? label = null)
        {
            edges.Add(new { id = $"edge_{++edgeCounter}", source, target, label });
        }

        (string entryId, string exitId) LayoutStep(StepDefinitionApiDto step, double x, double y)
        {
            var (cat, color, icon) = GetStepVisuals(step.Type);
            var nodeId = NextId();

            if (step.Type.Equals("Conditional", StringComparison.OrdinalIgnoreCase))
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = new Dictionary<string, object?>() });
                string lastId = nodeId;

                if (step.Then is not null)
                {
                    var (thenEntry, thenExit) = LayoutStep(step.Then, x + 200, y - 60);
                    AddEdge(nodeId, thenEntry, "then");
                    lastId = thenExit;
                }
                if (step.Else is not null)
                {
                    var (elseEntry, elseExit) = LayoutStep(step.Else, x + 200, y + 60);
                    AddEdge(nodeId, elseEntry, "else");
                    var mergeId = NextId();
                    nodes.Add(new { id = mergeId, type = "action", label = "‚Ü™ Merge", icon = "‚Ü™", category = "Core", color = "#6b7280", x = x + 400, y, config = new Dictionary<string, object?>() });
                    AddEdge(lastId, mergeId);
                    AddEdge(elseExit, mergeId);
                    return (nodeId, mergeId);
                }

                return (nodeId, lastId);
            }
            
            if (step.Type.Equals("Parallel", StringComparison.OrdinalIgnoreCase) && step.Steps is { Count: > 0 })
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = new Dictionary<string, object?>() });
                var joinId = NextId();
                double branchY = y - ((step.Steps.Count - 1) * 40.0);
                var branchExits = new List<string>();
                
                foreach (var child in step.Steps)
                {
                    var (childEntry, childExit) = LayoutStep(child, x + 200, branchY);
                    AddEdge(nodeId, childEntry);
                    branchExits.Add(childExit);
                    branchY += 80;
                }

                nodes.Add(new { id = joinId, type = "action", label = "‚Ü™ Join", icon = "‚Ü™", category = "Core", color = "#6b7280", x = x + 400, y, config = new Dictionary<string, object?>() });
                foreach (var exit in branchExits) AddEdge(exit, joinId);
                return (nodeId, joinId);
            }

            if ((step.Type.Equals("Retry", StringComparison.OrdinalIgnoreCase) 
                || step.Type.Equals("ForEach", StringComparison.OrdinalIgnoreCase)
                || step.Type.Equals("While", StringComparison.OrdinalIgnoreCase)
                || step.Type.Equals("DoWhile", StringComparison.OrdinalIgnoreCase)
                || step.Type.Equals("Saga", StringComparison.OrdinalIgnoreCase))
                && step.Steps is { Count: > 0 })
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = new Dictionary<string, object?>() });
                string lastChild = nodeId;
                double childX = x + 200;
                foreach (var child in step.Steps)
                {
                    var (childEntry, childExit) = LayoutStep(child, childX, y);
                    AddEdge(lastChild, childEntry);
                    lastChild = childExit;
                    childX += 200;
                }
                return (nodeId, lastChild);
            }

            if (step.Type.Equals("TryCatch", StringComparison.OrdinalIgnoreCase) && step.TryBody is { Count: > 0 })
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = new Dictionary<string, object?>() });
                string lastTry = nodeId;
                double childX = x + 200;
                foreach (var child in step.TryBody)
                {
                    var (childEntry, childExit) = LayoutStep(child, childX, y);
                    AddEdge(lastTry, childEntry);
                    lastTry = childExit;
                    childX += 200;
                }
                if (step.FinallyBody is { Count: > 0 })
                {
                    foreach (var fin in step.FinallyBody)
                    {
                        var (finEntry, finExit) = LayoutStep(fin, childX, y + 80);
                        AddEdge(lastTry, finEntry);
                        lastTry = finExit;
                        childX += 200;
                    }
                }
                return (nodeId, lastTry);
            }

            nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = new Dictionary<string, object?>() });
            return (nodeId, nodeId);
        }

        double currentX = 0;
        string? previousExit = null;

        foreach (var step in definition.Steps)
        {
            var (entryId, exitId) = LayoutStep(step, currentX, 100);
            if (previousExit is not null) AddEdge(previousExit, entryId);
            previousExit = exitId;
            
            currentX += step.Steps?.Count > 0 || step.Then is not null || step.TryBody?.Count > 0 
                ? 600 
                : 200;
        }

        await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", nodes.ToArray(), edges.ToArray());
        await JS.InvokeVoidAsync("workflowEditor.fitView");
    }

    private async Task HandleStepStatusChanged((string StepName, string Status) stepStatus)
    {
        try
        {
            await JS.InvokeVoidAsync("workflowEditor.updateNodeStatus", stepStatus.StepName, stepStatus.Status);
        }
        catch { }
    }

    private void HandleRunStatusChanged(string status)
    {
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run status: {status}");
        if (status is "Completed" or "Failed" or "Cancelled")
        {
            _activeRunId = null;
        }
        StateHasChanged();
    }

    private static string GetLogClass(string entry) => entry switch
    {
        _ when entry.Contains("‚ùå") || entry.Contains("üí•") => "text-red-400",
        _ when entry.Contains("‚úÖ") || entry.Contains("üèÅ") => "text-green-400",
        _ when entry.Contains("‚è≥") => "text-yellow-400",
        _ => ""
    };

    private static string GetSeverityIcon(string severity) => severity switch
    {
        "Error" => "üî¥",
        "Warning" => "üü°",
        "Info" => "üîµ",
        _ => "‚ö™"
    };

    private static string GetSeverityClass(string severity) => severity switch
    {
        "Error" => "text-red-400",
        "Warning" => "text-yellow-400",
        "Info" => "text-blue-400",
        _ => "text-gray-400"
    };

    public async ValueTask DisposeAsync()
    {
        _dotNetRef?.Dispose();
        try { await Shortcuts.DisposeAsync(); } catch { }
        try { await JS.InvokeVoidAsync("workflowEditor.destroy"); } catch { }
    }
}
