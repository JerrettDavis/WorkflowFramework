@inject IJSRuntime JS
@inject DashboardApiClient Api
@inject ToastService Toast
@inject KeyboardShortcutService Shortcuts
@implements IAsyncDisposable

<div class="flex flex-col h-full">
    <WorkflowToolbar WorkflowName="@_workflowName"
                     OnWorkflowNameChanged="name => { _workflowName = name; _dirty = true; }"
                     IsDirty="_dirty"
                     OnNew="HandleNew"
                     OnOpen="() => _showOpenDialog = true"
                     OnSave="HandleSave"
                     OnRun="HandleRun"
                     OnExportJson="HandleExportJson"
                     OnExportYaml="HandleExportYaml"
                     OnImportFile="HandleImport"
                     OnFitView="HandleFitView"
                     OnTemplates="() => _showTemplateBrowser = true"
                     OnValidate="HandleValidate"
                     ValidationErrorCount="ValidationErrorCount"
                     OnSettings="() => _showSettings = true"
                     OnShortcutsHelp="() => _showShortcutsHelp = true" />

    <div class="flex flex-1 overflow-hidden">
        <StepPalette />

        <div class="flex-1 relative" id="workflow-canvas"></div>

        <PropertiesPanel SelectedNodeId="@_selectedNodeId"
                         SelectedNodeType="@_selectedNodeType"
                         NodeConfig="_selectedNodeConfig"
                         OnConfigChanged="HandleConfigChanged" />
    </div>

    <ValidationPanel ValidationErrors="_validationErrors"
                     OnErrorClicked="HandleValidationErrorClicked" />

    <ExecutionPanel IsVisible="_showExecutionPanel"
                    OnToggle="() => _showExecutionPanel = !_showExecutionPanel"
                    LogEntries="_logEntries"
                    ActiveRunId="@_activeRunId"
                    OnRunStatusChanged="HandleRunStatusChanged"
                    OnStepStatusChanged="HandleStepStatusChanged" />
</div>

<TemplateBrowser IsVisible="_showTemplateBrowser"
                 OnClose="() => _showTemplateBrowser = false"
                 OnTemplateUsed="HandleTemplateUsed" />

<WorkflowListDialog IsVisible="_showOpenDialog"
                    OnClose="() => _showOpenDialog = false"
                    OnWorkflowSelected="HandleWorkflowOpened" />

<ShortcutsHelp IsVisible="_showShortcutsHelp"
               OnClose="() => _showShortcutsHelp = false" />

<ToastContainer />

@code {
    private bool _showShortcutsHelp;
    private bool _showSettings;
    private DotNetObjectReference<WorkflowDesigner>? _dotNetRef;
    private string _workflowName = "Untitled Workflow";
    private string? _currentWorkflowId;
    private bool _dirty;
    private string? _selectedNodeId;
    private string? _selectedNodeType;
    private Dictionary<string, object?> _selectedNodeConfig = new();
    private bool _showExecutionPanel;
    private List<string> _logEntries = [];
    private bool _showTemplateBrowser;
    private bool _showOpenDialog;
    private string? _activeRunId;
    private List<ValidationErrorDto> _validationErrors = [];

    private int ValidationErrorCount => _validationErrors.Count(e => e.Severity == "Error");

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("workflowEditor.initialize", "workflow-canvas", _dotNetRef, Array.Empty<object>(), Array.Empty<object>());

            // Initialize keyboard shortcuts
            Shortcuts.Register("Ctrl+S", HandleSave);
            Shortcuts.Register("Ctrl+N", HandleNew);
            Shortcuts.Register("Ctrl+O", () => { _showOpenDialog = true; StateHasChanged(); return Task.CompletedTask; });
            Shortcuts.Register("Ctrl+Enter", HandleRun);
            Shortcuts.Register("Escape", () => { _showShortcutsHelp = false; _showOpenDialog = false; _showTemplateBrowser = false; _showSettings = false; _selectedNodeId = null; StateHasChanged(); return Task.CompletedTask; });
            Shortcuts.Register("Delete", () => JS.InvokeVoidAsync("workflowEditor.deleteSelected").AsTask());
            Shortcuts.Register("Backspace", () => JS.InvokeVoidAsync("workflowEditor.deleteSelected").AsTask());
            Shortcuts.OnShowHelp += () => { _showShortcutsHelp = true; InvokeAsync(StateHasChanged); return Task.CompletedTask; };
            await Shortcuts.InitializeAsync();
        }
    }

    [JSInvokable]
    public void OnNodeSelected(string? nodeId, string? nodeType, Dictionary<string, object?>? config)
    {
        _selectedNodeId = nodeId;
        _selectedNodeType = nodeType;
        _selectedNodeConfig = config ?? new();
        StateHasChanged();
    }

    [JSInvokable]
    public void OnNodeAdded(string nodeId, string nodeType, double x, double y)
    {
        _dirty = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnNodeRemoved(string nodeId)
    {
        if (_selectedNodeId == nodeId) { _selectedNodeId = null; _selectedNodeType = null; }
        _dirty = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnEdgeCreated(string sourceId, string targetId) { _dirty = true; StateHasChanged(); }

    [JSInvokable]
    public void OnEdgeRemoved(string edgeId) { _dirty = true; StateHasChanged(); }

    [JSInvokable]
    public void OnCanvasChanged() { _dirty = true; StateHasChanged(); }

    private async Task HandleNew()
    {
        _workflowName = "Untitled Workflow";
        _currentWorkflowId = null;
        _dirty = false;
        _selectedNodeId = null;
        _selectedNodeType = null;
        _activeRunId = null;
        await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", Array.Empty<object>(), Array.Empty<object>());
    }

    private async Task HandleSave()
    {
        try
        {
            var definition = await JS.InvokeAsync<System.Text.Json.JsonElement>("workflowEditor.getWorkflowDefinition");
            var request = new CreateWorkflowRequest
            {
                Description = null,
                Definition = new WorkflowDefinitionDto { Name = _workflowName }
            };

            SavedWorkflowDefinition? result;
            if (_currentWorkflowId is not null)
                result = await Api.UpdateWorkflowAsync(_currentWorkflowId, request);
            else
                result = await Api.SaveWorkflowAsync(request);

            if (result is not null)
            {
                _currentWorkflowId = result.Id;
                _dirty = false;
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Saved workflow: {_workflowName} (id: {result.Id})");
                Toast.Success($"Saved '{_workflowName}'");
            }
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Save failed: {ex.Message}");
            Toast.Error($"Save failed: {ex.Message}");
        }
    }

    private async Task HandleValidate()
    {
        try
        {
            if (_currentWorkflowId is not null)
            {
                var result = await Api.ValidateWorkflowAsync(_currentWorkflowId);
                _validationErrors = result?.Errors ?? [];
            }
            else
            {
                var definition = new WorkflowDefinitionDto { Name = _workflowName };
                var result = await Api.ValidateDefinitionAsync(definition);
                _validationErrors = result?.Errors ?? [];
            }

            if (_validationErrors.Count == 0)
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] ‚úÖ Validation passed");
            else
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Validation: {_validationErrors.Count(e => e.Severity == "Error")} error(s), {_validationErrors.Count(e => e.Severity == "Warning")} warning(s)");
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Validation failed: {ex.Message}");
        }
    }

    private async Task HandleValidationErrorClicked(string? stepName)
    {
        if (stepName is not null)
        {
            await JS.InvokeVoidAsync("workflowEditor.selectNodeByName", stepName);
        }
    }

    private async Task HandleRun()
    {
        _showExecutionPanel = true;

        // Validate before running
        await HandleValidate();
        if (_validationErrors.Any(e => e.Severity == "Error"))
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] ‚ùå Cannot run: fix validation errors first");
            return;
        }

        if (_currentWorkflowId is null)
        {
            // Auto-save first
            await HandleSave();
            if (_currentWorkflowId is null)
            {
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Cannot run: workflow not saved");
                return;
            }
        }

        try
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Running workflow: {_workflowName}...");
            var run = await Api.RunWorkflowAsync(_currentWorkflowId);
            if (run is not null)
            {
                _activeRunId = run.RunId;
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run started: {run.RunId} (status: {run.Status})");
                Toast.Info($"Run started: {run.RunId}");
            }
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run failed: {ex.Message}");
            Toast.Error($"Run failed: {ex.Message}");
        }
    }

    private async Task HandleExportJson()
    {
        var definition = await JS.InvokeAsync<object>("workflowEditor.getWorkflowDefinition");
        var json = System.Text.Json.JsonSerializer.Serialize(definition, new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", json);
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] JSON copied to clipboard");
    }

    private async Task HandleExportYaml()
    {
        var definition = await JS.InvokeAsync<object>("workflowEditor.getWorkflowDefinition");
        var json = System.Text.Json.JsonSerializer.Serialize(definition);
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", json);
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Exported (JSON format - YAML requires server-side serializer)");
    }

    private async Task HandleImport(InputFileChangeEventArgs e)
    {
        try
        {
            using var stream = e.File.OpenReadStream(maxAllowedSize: 1024 * 1024);
            using var reader = new StreamReader(stream);
            var content = await reader.ReadToEndAsync();
            var parsed = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(content);

            if (parsed.TryGetProperty("nodes", out var nodes) && parsed.TryGetProperty("edges", out var edges))
            {
                await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", nodes, edges);
                _dirty = true;
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Imported workflow from {e.File.Name}");
            }
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Import failed: {ex.Message}");
        }
    }

    private async Task HandleFitView()
    {
        await JS.InvokeVoidAsync("workflowEditor.fitView");
    }

    private async Task HandleConfigChanged(Dictionary<string, object?> config)
    {
        _selectedNodeConfig = config;
        _dirty = true;
        if (_selectedNodeId is not null)
        {
            await JS.InvokeVoidAsync("workflowEditor.updateNode", _selectedNodeId, config);
        }
    }

    private async Task HandleTemplateUsed(SavedWorkflowDefinition saved)
    {
        _currentWorkflowId = saved.Id;
        _workflowName = saved.Definition.Name;
        _dirty = false;
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Loaded template as workflow: {_workflowName}");
        await LoadDefinitionIntoCanvas(saved.Definition);
    }

    private async Task HandleWorkflowOpened(SavedWorkflowDefinition saved)
    {
        _currentWorkflowId = saved.Id;
        _workflowName = saved.Definition.Name;
        _dirty = false;
        _selectedNodeId = null;
        _selectedNodeType = null;
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Opened workflow: {_workflowName}");
        await LoadDefinitionIntoCanvas(saved.Definition);
    }

    /// <summary>
    /// Converts a WorkflowDefinitionDto into canvas nodes + edges and loads them into React Flow.
    /// </summary>
    private async Task LoadDefinitionIntoCanvas(WorkflowDefinitionDto definition)
    {
        var nodes = new List<object>();
        var edges = new List<object>();
        int nodeCounter = 0;
        
        string NextId() => $"node_{++nodeCounter}";

        // Step type ‚Üí category/color/icon mapping
        static (string category, string color, string icon) GetStepVisuals(string type) => type.ToLowerInvariant() switch
        {
            "action" => ("Core", "#3b82f6", "‚¨°"),
            "conditional" => ("Core", "#3b82f6", "‚óá"),
            "parallel" => ("Core", "#3b82f6", "‚´ò"),
            "foreach" or "while" or "dowhile" => ("Core", "#3b82f6", "‚Üª"),
            "retry" => ("Core", "#3b82f6", "üîÑ"),
            "trycatch" => ("Core", "#3b82f6", "üõ°"),
            "timeout" => ("Core", "#3b82f6", "‚è±"),
            "delay" => ("Core", "#3b82f6", "‚è±"),
            "saga" => ("Core", "#3b82f6", "üìú"),
            "contentbasedrouter" or "messagefilter" or "splitter" or "aggregator" 
                or "recipientlist" or "wiretap" or "deadletterchannel" or "enricher" 
                or "normalizer" or "claimcheck" or "dynamicrouter" or "routingslip"
                => ("Integration", "#22c55e", "üîÄ"),
            "httpstep" => ("HTTP", "#14b8a6", "üåê"),
            "llmcallstep" or "agentdecisionstep" => ("AI/Agents", "#a855f7", "ü§ñ"),
            "agentloopstep" or "toolcallstep" => ("AI/Agents", "#a855f7", "üß†"),
            "datamapstep" or "validatestep" or "schemavalidatestep" => ("Data", "#f97316", "üó∫"),
            "publisheventstep" or "subscribeeventstep" => ("Events", "#eab308", "‚ö°"),
            "humantaskstep" or "approvalstep" => ("Human Tasks", "#ec4899", "‚úÖ"),
            _ => ("Core", "#3b82f6", "‚¨°")
        };

        int edgeCounter = 0;
        void AddEdge(string source, string target, string? label = null)
        {
            edges.Add(new { id = $"edge_{++edgeCounter}", source, target, label });
        }

        // Recursively flatten steps into positioned nodes, returning the IDs of entry and exit nodes
        (string entryId, string exitId) LayoutStep(StepDefinitionApiDto step, double x, double y)
        {
            var (cat, color, icon) = GetStepVisuals(step.Type);
            var nodeId = NextId();

            // For container types, create the main node then layout children
            if (step.Type.Equals("Conditional", StringComparison.OrdinalIgnoreCase))
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = new Dictionary<string, object?>() });
                string lastId = nodeId;

                if (step.Then is not null)
                {
                    var (thenEntry, thenExit) = LayoutStep(step.Then, x + 200, y - 60);
                    AddEdge(nodeId, thenEntry, "then");
                    lastId = thenExit;
                }
                if (step.Else is not null)
                {
                    var (elseEntry, elseExit) = LayoutStep(step.Else, x + 200, y + 60);
                    AddEdge(nodeId, elseEntry, "else");
                    // Merge node
                    var mergeId = NextId();
                    nodes.Add(new { id = mergeId, type = "action", label = "‚Ü™ Merge", icon = "‚Ü™", category = "Core", color = "#6b7280", x = x + 400, y, config = new Dictionary<string, object?>() });
                    AddEdge(lastId, mergeId);
                    AddEdge(elseExit, mergeId);
                    return (nodeId, mergeId);
                }

                return (nodeId, lastId);
            }
            
            if (step.Type.Equals("Parallel", StringComparison.OrdinalIgnoreCase) && step.Steps is { Count: > 0 })
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = new Dictionary<string, object?>() });
                var joinId = NextId();
                double branchY = y - ((step.Steps.Count - 1) * 40.0);
                var branchExits = new List<string>();
                
                foreach (var child in step.Steps)
                {
                    var (childEntry, childExit) = LayoutStep(child, x + 200, branchY);
                    AddEdge(nodeId, childEntry);
                    branchExits.Add(childExit);
                    branchY += 80;
                }

                nodes.Add(new { id = joinId, type = "action", label = "‚Ü™ Join", icon = "‚Ü™", category = "Core", color = "#6b7280", x = x + 400, y, config = new Dictionary<string, object?>() });
                foreach (var exit in branchExits) AddEdge(exit, joinId);
                return (nodeId, joinId);
            }

            if ((step.Type.Equals("Retry", StringComparison.OrdinalIgnoreCase) 
                || step.Type.Equals("ForEach", StringComparison.OrdinalIgnoreCase)
                || step.Type.Equals("While", StringComparison.OrdinalIgnoreCase)
                || step.Type.Equals("DoWhile", StringComparison.OrdinalIgnoreCase)
                || step.Type.Equals("Saga", StringComparison.OrdinalIgnoreCase))
                && step.Steps is { Count: > 0 })
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = new Dictionary<string, object?>() });
                string lastChild = nodeId;
                double childX = x + 200;
                foreach (var child in step.Steps)
                {
                    var (childEntry, childExit) = LayoutStep(child, childX, y);
                    AddEdge(lastChild, childEntry);
                    lastChild = childExit;
                    childX += 200;
                }
                return (nodeId, lastChild);
            }

            if (step.Type.Equals("TryCatch", StringComparison.OrdinalIgnoreCase) && step.TryBody is { Count: > 0 })
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = new Dictionary<string, object?>() });
                string lastTry = nodeId;
                double childX = x + 200;
                foreach (var child in step.TryBody)
                {
                    var (childEntry, childExit) = LayoutStep(child, childX, y);
                    AddEdge(lastTry, childEntry);
                    lastTry = childExit;
                    childX += 200;
                }
                if (step.FinallyBody is { Count: > 0 })
                {
                    foreach (var fin in step.FinallyBody)
                    {
                        var (finEntry, finExit) = LayoutStep(fin, childX, y + 80);
                        AddEdge(lastTry, finEntry);
                        lastTry = finExit;
                        childX += 200;
                    }
                }
                return (nodeId, lastTry);
            }

            // Simple leaf node
            nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = new Dictionary<string, object?>() });
            return (nodeId, nodeId);
        }

        // Layout top-level steps sequentially
        double currentX = 0;
        string? previousExit = null;

        foreach (var step in definition.Steps)
        {
            var (entryId, exitId) = LayoutStep(step, currentX, 100);
            if (previousExit is not null) AddEdge(previousExit, entryId);
            previousExit = exitId;
            
            // Advance X based on how many nodes were added at this level
            currentX += step.Steps?.Count > 0 || step.Then is not null || step.TryBody?.Count > 0 
                ? 600 
                : 200;
        }

        await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", nodes.ToArray(), edges.ToArray());
        await JS.InvokeVoidAsync("workflowEditor.fitView");
    }

    private async Task HandleStepStatusChanged((string StepName, string Status) stepStatus)
    {
        try
        {
            await JS.InvokeVoidAsync("workflowEditor.updateNodeStatus", stepStatus.StepName, stepStatus.Status);
        }
        catch { /* JS interop may fail if canvas not ready */ }
    }

    private void HandleRunStatusChanged(string status)
    {
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run status: {status}");
        if (status is "Completed" or "Failed" or "Cancelled")
        {
            _activeRunId = null;
        }
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        _dotNetRef?.Dispose();
        try { await Shortcuts.DisposeAsync(); } catch { }
        try { await JS.InvokeVoidAsync("workflowEditor.destroy"); } catch { }
    }
}
