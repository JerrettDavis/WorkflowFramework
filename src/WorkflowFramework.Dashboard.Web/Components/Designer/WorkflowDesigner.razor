@inject IJSRuntime JS
@inject DashboardApiClient Api
@inject ToastService Toast
@inject KeyboardShortcutService Shortcuts
@implements IAsyncDisposable

<div class="flex flex-col h-full">
    <WorkflowToolbar WorkflowName="@_workflowName"
                     OnWorkflowNameChanged="name => { _workflowName = name; _dirty = true; }"
                     IsDirty="_dirty"
                     OnNew="HandleNew"
                     OnOpen="() => _showOpenDialog = true"
                     OnSave="HandleSave"
                     OnRun="HandleRun"
                     OnExportJson="HandleExportJson"
                     OnExportYaml="HandleExportYaml"
                     OnImportFile="HandleImport"
                     OnFitView="HandleFitView"
                     OnTemplates="() => _showTemplateBrowser = true"
                     OnValidate="HandleValidate"
                     ValidationErrorCount="ValidationErrorCount"
                     OnSettings="() => _showSettings = true"
                     OnShortcutsHelp="() => _showShortcutsHelp = true" />

    <div class="flex flex-1 overflow-hidden">
        <StepPalette />

        <div class="flex-1 relative" id="workflow-canvas"></div>

        <PropertiesPanel SelectedNodeId="@_selectedNodeId"
                         SelectedNodeType="@_selectedNodeType"
                         NodeConfig="_selectedNodeConfig"
                         OnConfigChanged="HandleConfigChanged"
                         Connections="_selectedNodeConnections"
                         OnConnectionClicked="HandleFocusNode" />
    </div>

    @* Tabbed bottom panels *@
    <div class="border-t border-gray-700 bg-gray-800" data-testid="bottom-tabs">
        <div class="flex items-center border-b border-gray-700">
            <button @onclick='() => _activeBottomTab = "output"'
                    class="px-4 py-1.5 text-xs @(_activeBottomTab == "output" ? "text-blue-400 border-b-2 border-blue-400 bg-gray-850" : "text-gray-400 hover:text-gray-200")"
                    data-testid="tab-output">
                Output
                @if (_activeRunId is not null)
                {
                    <span class="ml-1 text-yellow-400">‚óè</span>
                }
            </button>
            <button @onclick='() => { _activeBottomTab = "steps"; RefreshStepList(); }'
                    class="px-4 py-1.5 text-xs @(_activeBottomTab == "steps" ? "text-blue-400 border-b-2 border-blue-400 bg-gray-850" : "text-gray-400 hover:text-gray-200")"
                    data-testid="tab-steps">
                Steps
            </button>
            <button @onclick='() => _activeBottomTab = "triggers"'
                    class="px-4 py-1.5 text-xs @(_activeBottomTab == "triggers" ? "text-blue-400 border-b-2 border-blue-400 bg-gray-850" : "text-gray-400 hover:text-gray-200")"
                    data-testid="tab-triggers">
                ‚ö° Triggers
            </button>
            <button @onclick='() => _activeBottomTab = "validation"'
                    class="px-4 py-1.5 text-xs @(_activeBottomTab == "validation" ? "text-blue-400 border-b-2 border-blue-400 bg-gray-850" : "text-gray-400 hover:text-gray-200")"
                    data-testid="tab-validation">
                Validation
                @if (_validationErrors.Count > 0)
                {
                    <span class="ml-1 px-1.5 py-0.5 rounded-full text-[10px] bg-red-500/20 text-red-400">@ValidationErrorCount</span>
                }
            </button>
            <div class="flex-1"></div>
            <button @onclick="() => _bottomPanelCollapsed = !_bottomPanelCollapsed"
                    class="px-3 py-1.5 text-xs text-gray-500 hover:text-gray-300"
                    data-testid="toggle-bottom-panel">
                @(_bottomPanelCollapsed ? "‚ñ≤" : "‚ñº")
            </button>
        </div>

        @if (!_bottomPanelCollapsed)
        {
            <div class="h-40">
                @if (_activeBottomTab == "output")
                {
                    <div class="h-full overflow-y-auto p-3 bg-gray-900 font-mono text-xs text-gray-300" data-testid="output-content">
                        @if (_logEntries.Count == 0)
                        {
                            <p class="text-gray-600">No output yet. Run a workflow to see results.</p>
                        }
                        else
                        {
                            @foreach (var entry in _logEntries)
                            {
                                <div class="py-0.5 @GetLogClass(entry)">@entry</div>
                            }
                        }
                    </div>
                }
                else if (_activeBottomTab == "steps")
                {
                    <StepListPanel @ref="_stepListPanel"
                                   SelectedNodeId="@_selectedNodeId"
                                   OnNodeClicked="HandleFocusNode" />
                }
                else if (_activeBottomTab == "triggers")
                {
                    <TriggerPanel WorkflowId="@_currentWorkflowId" />
                }
                else if (_activeBottomTab == "validation")
                {
                    <div class="h-full overflow-y-auto bg-gray-900" data-testid="validation-content">
                        @if (_validationErrors.Count == 0)
                        {
                            <div class="p-3 text-gray-600 text-xs">No validation errors. Click Validate to check.</div>
                        }
                        else
                        {
                            @foreach (var error in _validationErrors)
                            {
                                <button @onclick="() => HandleValidationErrorClicked(error.StepName)"
                                        class="w-full flex items-center gap-2 px-3 py-1 text-xs hover:bg-gray-700 text-left">
                                    <span class="@GetSeverityClass(error.Severity)">@GetSeverityIcon(error.Severity)</span>
                                    @if (error.StepName is not null)
                                    {
                                        <span class="text-blue-400 font-mono">@error.StepName</span>
                                    }
                                    <span class="text-gray-300">@error.Message</span>
                                </button>
                            }
                        }
                    </div>
                }
            </div>
        }
    </div>
</div>

<TemplateBrowser IsVisible="_showTemplateBrowser"
                 OnClose="() => _showTemplateBrowser = false"
                 OnTemplateUsed="HandleTemplateUsed" />

<WorkflowListDialog IsVisible="_showOpenDialog"
                    OnClose="() => _showOpenDialog = false"
                    OnWorkflowSelected="HandleWorkflowOpened" />

<ShortcutsHelp IsVisible="_showShortcutsHelp"
               OnClose="() => _showShortcutsHelp = false" />

<ToastContainer />

@code {
    private bool _showShortcutsHelp;
    private bool _showSettings;
    private DotNetObjectReference<WorkflowDesigner>? _dotNetRef;
    private string _workflowName = "Untitled Workflow";
    private string? _currentWorkflowId;
    private bool _dirty;
    private string? _selectedNodeId;
    private string? _selectedNodeType;
    private Dictionary<string, object?> _selectedNodeConfig = new();
    private PropertiesPanel.NodeConnections? _selectedNodeConnections;
    private bool _showTemplateBrowser;
    private bool _showOpenDialog;
    private string? _activeRunId;
    private List<ValidationErrorDto> _validationErrors = [];
    private List<string> _logEntries = [];
    private string _activeBottomTab = "output";
    private bool _bottomPanelCollapsed;
    private StepListPanel? _stepListPanel;

    private int ValidationErrorCount => _validationErrors.Count(e => e.Severity == "Error");

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("workflowEditor.initialize", "workflow-canvas", _dotNetRef, Array.Empty<object>(), Array.Empty<object>());

            Shortcuts.Register("Ctrl+S", HandleSave);
            Shortcuts.Register("Ctrl+N", HandleNew);
            Shortcuts.Register("Ctrl+O", () => { _showOpenDialog = true; StateHasChanged(); return Task.CompletedTask; });
            Shortcuts.Register("Ctrl+Enter", HandleRun);
            Shortcuts.Register("Escape", () => { _showShortcutsHelp = false; _showOpenDialog = false; _showTemplateBrowser = false; _showSettings = false; _selectedNodeId = null; StateHasChanged(); return Task.CompletedTask; });
            Shortcuts.Register("Delete", () => JS.InvokeVoidAsync("workflowEditor.deleteSelected").AsTask());
            Shortcuts.Register("Backspace", () => JS.InvokeVoidAsync("workflowEditor.deleteSelected").AsTask());
            Shortcuts.OnShowHelp += () => { _showShortcutsHelp = true; InvokeAsync(StateHasChanged); return Task.CompletedTask; };
            await Shortcuts.InitializeAsync();
        }
    }

    [JSInvokable]
    public async void OnNodeSelected(string? nodeId, string? nodeType, Dictionary<string, object?>? config)
    {
        _selectedNodeId = nodeId;
        _selectedNodeType = nodeType;
        _selectedNodeConfig = config ?? new();

        if (nodeId is not null)
        {
            try
            {
                var connData = await JS.InvokeAsync<System.Text.Json.JsonElement>("workflowEditor.getNodeConnections", nodeId);
                _selectedNodeConnections = new PropertiesPanel.NodeConnections();
                if (connData.TryGetProperty("inputs", out var inputs))
                {
                    foreach (var item in inputs.EnumerateArray())
                    {
                        _selectedNodeConnections.Inputs.Add(new PropertiesPanel.ConnectionInfo
                        {
                            Id = item.GetProperty("id").GetString() ?? "",
                            Label = item.GetProperty("label").GetString() ?? "",
                            EdgeLabel = item.TryGetProperty("edgeLabel", out var el) && el.ValueKind != System.Text.Json.JsonValueKind.Null ? el.GetString() : null
                        });
                    }
                }
                if (connData.TryGetProperty("outputs", out var outputs))
                {
                    foreach (var item in outputs.EnumerateArray())
                    {
                        _selectedNodeConnections.Outputs.Add(new PropertiesPanel.ConnectionInfo
                        {
                            Id = item.GetProperty("id").GetString() ?? "",
                            Label = item.GetProperty("label").GetString() ?? "",
                            EdgeLabel = item.TryGetProperty("edgeLabel", out var el) && el.ValueKind != System.Text.Json.JsonValueKind.Null ? el.GetString() : null
                        });
                    }
                }
            }
            catch { _selectedNodeConnections = null; }
        }
        else
        {
            _selectedNodeConnections = null;
        }

        StateHasChanged();
    }

    [JSInvokable]
    public void OnNodeAdded(string nodeId, string nodeType, double x, double y)
    {
        _dirty = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnNodeRemoved(string nodeId)
    {
        if (_selectedNodeId == nodeId) { _selectedNodeId = null; _selectedNodeType = null; _selectedNodeConnections = null; }
        _dirty = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnEdgeCreated(string sourceId, string targetId) { _dirty = true; StateHasChanged(); }

    [JSInvokable]
    public void OnEdgeRemoved(string edgeId) { _dirty = true; StateHasChanged(); }

    [JSInvokable]
    public void OnCanvasChanged() { _dirty = true; StateHasChanged(); }

    private async Task HandleFocusNode(string nodeId)
    {
        await JS.InvokeVoidAsync("workflowEditor.focusNode", nodeId);
    }

    private async void RefreshStepList()
    {
        if (_stepListPanel is not null)
        {
            await Task.Yield(); // let render complete
            await _stepListPanel.RefreshAsync();
        }
    }

    private async Task HandleNew()
    {
        _workflowName = "Untitled Workflow";
        _currentWorkflowId = null;
        _dirty = false;
        _selectedNodeId = null;
        _selectedNodeType = null;
        _selectedNodeConnections = null;
        _activeRunId = null;
        await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", Array.Empty<object>(), Array.Empty<object>());
    }

    private async Task HandleSave()
    {
        try
        {
            var canvasData = await JS.InvokeAsync<System.Text.Json.JsonElement>("workflowEditor.getWorkflowDefinition");
            var request = new CreateWorkflowRequest
            {
                Description = null,
                Definition = CanvasToDefinition(canvasData)
            };

            SavedWorkflowDefinition? result;
            if (_currentWorkflowId is not null)
                result = await Api.UpdateWorkflowAsync(_currentWorkflowId, request);
            else
                result = await Api.SaveWorkflowAsync(request);

            if (result is not null)
            {
                _currentWorkflowId = result.Id;
                _dirty = false;
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Saved workflow: {_workflowName} (id: {result.Id})");
                Toast.Success($"Saved '{_workflowName}'");
            }
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Save failed: {ex.Message}");
            Toast.Error($"Save failed: {ex.Message}");
        }
    }

    private async Task HandleValidate()
    {
        try
        {
            if (_currentWorkflowId is not null)
            {
                var result = await Api.ValidateWorkflowAsync(_currentWorkflowId);
                _validationErrors = result?.Errors ?? [];
            }
            else
            {
                var canvasData = await JS.InvokeAsync<System.Text.Json.JsonElement>("workflowEditor.getWorkflowDefinition");
                var definition = CanvasToDefinition(canvasData);
                var result = await Api.ValidateDefinitionAsync(definition);
                _validationErrors = result?.Errors ?? [];
            }

            if (_validationErrors.Count == 0)
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] ‚úÖ Validation passed");
            else
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Validation: {_validationErrors.Count(e => e.Severity == "Error")} error(s), {_validationErrors.Count(e => e.Severity == "Warning")} warning(s)");
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Validation failed: {ex.Message}");
        }
    }

    private async Task HandleValidationErrorClicked(string? stepName)
    {
        if (stepName is not null)
        {
            await JS.InvokeVoidAsync("workflowEditor.selectNodeByName", stepName);
        }
    }

    private async Task HandleRun()
    {
        _activeBottomTab = "output";
        _bottomPanelCollapsed = false;

        await HandleValidate();
        if (_validationErrors.Any(e => e.Severity == "Error"))
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] ‚ùå Cannot run: fix validation errors first");
            return;
        }

        if (_currentWorkflowId is null)
        {
            await HandleSave();
            if (_currentWorkflowId is null)
            {
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Cannot run: workflow not saved");
                return;
            }
        }

        try
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Running workflow: {_workflowName}...");
            var run = await Api.RunWorkflowAsync(_currentWorkflowId);
            if (run is not null)
            {
                _activeRunId = run.RunId;
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run started: {run.RunId} (status: {run.Status})");
                Toast.Info($"Run started: {run.RunId}");
            }
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run failed: {ex.Message}");
            Toast.Error($"Run failed: {ex.Message}");
        }
    }

    private async Task HandleExportJson()
    {
        try
        {
            if (_currentWorkflowId is not null)
            {
                var export = await Api.ExportWorkflowAsync(_currentWorkflowId);
                if (export is not null)
                {
                    await JS.InvokeVoidAsync("downloadJson", $"{_workflowName}.json", export);
                    _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Exported workflow as JSON file");
                    Toast.Success("Exported as JSON");
                    return;
                }
            }
            // Fallback: copy canvas data to clipboard
            var definition = await JS.InvokeAsync<object>("workflowEditor.getWorkflowDefinition");
            var json = System.Text.Json.JsonSerializer.Serialize(definition, new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", json);
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] JSON copied to clipboard (save workflow first for full export)");
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Export failed: {ex.Message}");
            Toast.Error($"Export failed: {ex.Message}");
        }
    }

    private async Task HandleExportYaml()
    {
        try
        {
            if (_currentWorkflowId is not null)
            {
                var yaml = await Api.ExportWorkflowYamlAsync(_currentWorkflowId);
                await JS.InvokeVoidAsync("downloadText", $"{_workflowName}.yaml", yaml, "text/yaml");
                _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Exported workflow as YAML file");
                Toast.Success("Exported as YAML");
                return;
            }
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Save workflow first to export as YAML");
            Toast.Warning("Save workflow first to export as YAML");
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] YAML export failed: {ex.Message}");
            Toast.Error($"YAML export failed: {ex.Message}");
        }
    }

    private async Task HandleImport(InputFileChangeEventArgs e)
    {
        try
        {
            using var stream = e.File.OpenReadStream(maxAllowedSize: 1024 * 1024);
            using var reader = new StreamReader(stream);
            var content = await reader.ReadToEndAsync();

            // Try WorkflowExportDto format (API import)
            try
            {
                var parsed = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(content);

                // Check if it's a canvas format (nodes/edges)
                if (parsed.TryGetProperty("nodes", out var nodes) && parsed.TryGetProperty("edges", out var edges))
                {
                    await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", nodes, edges);
                    _dirty = true;
                    _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Imported workflow from {e.File.Name}");
                    return;
                }

                // Try API import (WorkflowExportDto format)
                if (parsed.TryGetProperty("definition", out _) || parsed.TryGetProperty("formatVersion", out _))
                {
                    var imported = await Api.ImportWorkflowAsync(content);
                    if (imported is not null)
                    {
                        _currentWorkflowId = imported.Id;
                        _workflowName = imported.Definition.Name;
                        _dirty = false;
                        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Imported workflow '{imported.Definition.Name}' from {e.File.Name}");
                        Toast.Success($"Imported '{imported.Definition.Name}'");
                        await LoadDefinitionIntoCanvas(imported.Definition);
                        return;
                    }
                }
            }
            catch { }

            // Try YAML import
            if (e.File.Name.EndsWith(".yaml", StringComparison.OrdinalIgnoreCase) || e.File.Name.EndsWith(".yml", StringComparison.OrdinalIgnoreCase))
            {
                var imported = await Api.ImportWorkflowYamlAsync(content);
                if (imported is not null)
                {
                    _currentWorkflowId = imported.Id;
                    _workflowName = imported.Definition.Name;
                    _dirty = false;
                    _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Imported YAML workflow '{imported.Definition.Name}' from {e.File.Name}");
                    Toast.Success($"Imported '{imported.Definition.Name}'");
                    await LoadDefinitionIntoCanvas(imported.Definition);
                    return;
                }
            }

            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Could not import from {e.File.Name}");
            Toast.Error("Could not import file");
        }
        catch (Exception ex)
        {
            _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Import failed: {ex.Message}");
            Toast.Error($"Import failed: {ex.Message}");
        }
    }

    private async Task HandleFitView()
    {
        await JS.InvokeVoidAsync("workflowEditor.fitView");
    }

    private async Task HandleConfigChanged(Dictionary<string, object?> config)
    {
        _selectedNodeConfig = config;
        _dirty = true;
        if (_selectedNodeId is not null)
        {
            await JS.InvokeVoidAsync("workflowEditor.updateNode", _selectedNodeId, config);
        }
    }

    private async Task HandleTemplateUsed(SavedWorkflowDefinition saved)
    {
        _currentWorkflowId = saved.Id;
        _workflowName = saved.Definition.Name;
        _dirty = false;
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Loaded template as workflow: {_workflowName}");
        await LoadDefinitionIntoCanvas(saved.Definition);
    }

    private async Task HandleWorkflowOpened(SavedWorkflowDefinition saved)
    {
        _currentWorkflowId = saved.Id;
        _workflowName = saved.Definition.Name;
        _dirty = false;
        _selectedNodeId = null;
        _selectedNodeType = null;
        _selectedNodeConnections = null;
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Opened workflow: {_workflowName}");
        await LoadDefinitionIntoCanvas(saved.Definition);
    }

    /// <summary>
    /// Reconstructs a WorkflowDefinitionDto from the flat nodes/edges returned by JS getWorkflowDefinition().
    /// </summary>
    private WorkflowDefinitionDto CanvasToDefinition(System.Text.Json.JsonElement canvasData)
    {
        var dto = new WorkflowDefinitionDto { Name = _workflowName };

        if (!canvasData.TryGetProperty("nodes", out var nodesEl) || !canvasData.TryGetProperty("edges", out var edgesEl))
            return dto;

        // Parse nodes and edges into working lists
        var nodes = new List<CanvasNode>();
        foreach (var n in nodesEl.EnumerateArray())
        {
            var cn = new CanvasNode
            {
                Id = n.GetProperty("id").GetString() ?? "",
                Type = n.TryGetProperty("type", out var t) ? t.GetString() ?? "Action" : "Action",
                Label = n.TryGetProperty("label", out var l) ? l.GetString() ?? "" : "",
                Config = new Dictionary<string, string>()
            };
            if (n.TryGetProperty("config", out var cfg) && cfg.ValueKind == System.Text.Json.JsonValueKind.Object)
            {
                foreach (var prop in cfg.EnumerateObject())
                {
                    cn.Config[prop.Name] = prop.Value.ValueKind == System.Text.Json.JsonValueKind.String
                        ? prop.Value.GetString() ?? ""
                        : prop.Value.GetRawText();
                }
            }
            nodes.Add(cn);
        }

        var edges = new List<CanvasEdge>();
        foreach (var e in edgesEl.EnumerateArray())
        {
            edges.Add(new CanvasEdge
            {
                Source = e.GetProperty("source").GetString() ?? "",
                Target = e.GetProperty("target").GetString() ?? "",
                Label = e.TryGetProperty("label", out var el) && el.ValueKind == System.Text.Json.JsonValueKind.String ? el.GetString() : null
            });
        }

        var nodeMap = nodes.ToDictionary(n => n.Id);
        var outEdges = edges.GroupBy(e => e.Source).ToDictionary(g => g.Key, g => g.ToList());
        var inEdges = edges.GroupBy(e => e.Target).ToDictionary(g => g.Key, g => g.ToList());

        // Synthetic merge/join nodes (generated by LoadDefinitionIntoCanvas) should be skipped
        bool IsSynthetic(CanvasNode n) => n.Label is "‚Ü™ Merge" or "‚Ü™ Join";

        // Find root nodes: no incoming edges and not synthetic
        var roots = nodes.Where(n => !IsSynthetic(n) && !inEdges.ContainsKey(n.Id)).ToList();

        // Sort roots left-to-right by original insertion order (node id has counter)
        roots.Sort((a, b) => string.Compare(a.Id, b.Id, StringComparison.Ordinal));

        var visited = new HashSet<string>();

        StepDefinitionApiDto? BuildStep(string nodeId)
        {
            if (!visited.Add(nodeId)) return null;
            if (!nodeMap.TryGetValue(nodeId, out var node)) return null;
            if (IsSynthetic(node)) return null;

            var step = new StepDefinitionApiDto
            {
                Name = node.Label,
                Type = node.Type,
                Config = node.Config.Count > 0 ? new Dictionary<string, string>(node.Config) : null
            };

            // Extract well-known properties from config into DTO fields
            if (step.Config is not null)
            {
                if (step.Config.TryGetValue("maxAttempts", out var ma) && int.TryParse(ma, out var maxAtt))
                {
                    step.MaxAttempts = maxAtt;
                    step.Config.Remove("maxAttempts");
                }
                if (step.Config.TryGetValue("timeoutSeconds", out var ts) && double.TryParse(ts, out var timeout))
                {
                    step.TimeoutSeconds = timeout;
                    step.Config.Remove("timeoutSeconds");
                }
                if (step.Config.TryGetValue("catchTypes", out var ct) && !string.IsNullOrWhiteSpace(ct))
                {
                    step.CatchTypes = ct.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries).ToList();
                    step.Config.Remove("catchTypes");
                }
                if (step.Config.Count == 0) step.Config = null;
            }

            var outs = outEdges.GetValueOrDefault(node.Id) ?? [];

            if (node.Type.Equals("Conditional", StringComparison.OrdinalIgnoreCase))
            {
                var thenEdge = outs.FirstOrDefault(e => e.Label == "then");
                var elseEdge = outs.FirstOrDefault(e => e.Label == "else");

                if (thenEdge is not null)
                    step.Then = BuildStep(thenEdge.Target) ?? BuildChainFrom(thenEdge.Target);
                if (elseEdge is not null)
                    step.Else = BuildStep(elseEdge.Target) ?? BuildChainFrom(elseEdge.Target);

                return step;
            }

            if (node.Type.Equals("Parallel", StringComparison.OrdinalIgnoreCase))
            {
                step.Steps = [];
                foreach (var edge in outs)
                {
                    var child = BuildStep(edge.Target);
                    if (child is not null) step.Steps.Add(child);
                }
                if (step.Steps.Count == 0) step.Steps = null;
                return step;
            }

            if (node.Type is "Retry" or "ForEach" or "While" or "DoWhile" or "Saga"
                && outs.Count > 0)
            {
                step.Steps = [];
                // Children are chained sequentially from this node
                var childId = outs[0].Target;
                while (childId is not null)
                {
                    var child = BuildStep(childId);
                    if (child is null) break;
                    step.Steps.Add(child);
                    // Follow the single outgoing edge from child (skip synthetic)
                    var childOuts = outEdges.GetValueOrDefault(childId);
                    childId = childOuts?.FirstOrDefault()?.Target;
                    if (childId is not null && nodeMap.TryGetValue(childId, out var next) && IsSynthetic(next))
                        childId = null;
                }
                if (step.Steps.Count == 0) step.Steps = null;
                return step;
            }

            if (node.Type.Equals("TryCatch", StringComparison.OrdinalIgnoreCase) && outs.Count > 0)
            {
                step.TryBody = [];
                var childId = outs[0].Target;
                while (childId is not null)
                {
                    var child = BuildStep(childId);
                    if (child is null) break;
                    step.TryBody.Add(child);
                    var childOuts = outEdges.GetValueOrDefault(childId);
                    childId = childOuts?.FirstOrDefault()?.Target;
                    if (childId is not null && nodeMap.TryGetValue(childId, out var next) && IsSynthetic(next))
                        childId = null;
                }
                if (step.TryBody.Count == 0) step.TryBody = null;
                return step;
            }

            return step;
        }

        // Build a chain following sequential edges from a node (skipping synthetic nodes)
        StepDefinitionApiDto? BuildChainFrom(string nodeId)
        {
            return BuildStep(nodeId);
        }

        // Walk roots and their sequential successors
        foreach (var root in roots)
        {
            var step = BuildStep(root.Id);
            if (step is null) continue;
            dto.Steps.Add(step);

            // Follow sequential chain from this root
            var currentId = root.Id;
            while (true)
            {
                var outs = outEdges.GetValueOrDefault(currentId);
                if (outs is null || outs.Count == 0) break;
                // For non-container nodes, the unlabeled edge is the sequential next
                if (nodeMap.TryGetValue(currentId, out var cur) &&
                    cur.Type is "Conditional" or "Parallel" or "Retry" or "ForEach" or "While" or "DoWhile" or "Saga" or "TryCatch")
                {
                    // Container children are already handled; find the merge/join exit
                    var mergeTargets = outs
                        .Select(e => e.Target)
                        .SelectMany(t => FindMergeExit(t))
                        .Distinct()
                        .ToList();
                    if (mergeTargets.Count == 1)
                    {
                        currentId = mergeTargets[0];
                        // Follow from merge exit
                        var mergeOuts = outEdges.GetValueOrDefault(currentId);
                        if (mergeOuts is { Count: 1 })
                        {
                            var nextId = mergeOuts[0].Target;
                            if (nodeMap.TryGetValue(nextId, out var nn) && !IsSynthetic(nn))
                            {
                                var nextStep = BuildStep(nextId);
                                if (nextStep is not null)
                                {
                                    dto.Steps.Add(nextStep);
                                    currentId = nextId;
                                    continue;
                                }
                            }
                        }
                    }
                    break;
                }

                // Simple sequential: single unlabeled outgoing edge
                var seqEdge = outs.FirstOrDefault(e => e.Label is null);
                if (seqEdge is null) break;
                var targetNode = nodeMap.GetValueOrDefault(seqEdge.Target);
                if (targetNode is null || IsSynthetic(targetNode)) break;
                var seqStep = BuildStep(seqEdge.Target);
                if (seqStep is null) break;
                dto.Steps.Add(seqStep);
                currentId = seqEdge.Target;
            }
        }

        return dto;

        // Helper: find merge/join node reachable from a node
        IEnumerable<string> FindMergeExit(string fromId)
        {
            var seen = new HashSet<string>();
            var queue = new Queue<string>();
            queue.Enqueue(fromId);
            while (queue.Count > 0)
            {
                var id = queue.Dequeue();
                if (!seen.Add(id)) continue;
                if (nodeMap.TryGetValue(id, out var n) && IsSynthetic(n))
                {
                    yield return id;
                    continue;
                }
                foreach (var e in outEdges.GetValueOrDefault(id) ?? [])
                    queue.Enqueue(e.Target);
            }
        }
    }

    private sealed class CanvasNode
    {
        public string Id { get; set; } = "";
        public string Type { get; set; } = "";
        public string Label { get; set; } = "";
        public Dictionary<string, string> Config { get; set; } = new();
    }

    private sealed class CanvasEdge
    {
        public string Source { get; set; } = "";
        public string Target { get; set; } = "";
        public string? Label { get; set; }
    }

    private async Task LoadDefinitionIntoCanvas(WorkflowDefinitionDto definition)
    {
        var nodes = new List<object>();
        var edges = new List<object>();
        int nodeCounter = 0;
        
        string NextId() => $"node_{++nodeCounter}";

        static (string category, string color, string icon) GetStepVisuals(string type) => type.ToLowerInvariant() switch
        {
            "action" => ("Core", "#3b82f6", "‚¨°"),
            "conditional" => ("Core", "#3b82f6", "‚óá"),
            "parallel" => ("Core", "#3b82f6", "‚´ò"),
            "foreach" or "while" or "dowhile" => ("Core", "#3b82f6", "‚Üª"),
            "retry" => ("Core", "#3b82f6", "üîÑ"),
            "trycatch" => ("Core", "#3b82f6", "üõ°"),
            "timeout" => ("Core", "#3b82f6", "‚è±"),
            "delay" => ("Core", "#3b82f6", "‚è±"),
            "saga" => ("Core", "#3b82f6", "üìú"),
            "contentbasedrouter" or "messagefilter" or "splitter" or "aggregator" 
                or "recipientlist" or "wiretap" or "deadletterchannel" or "enricher" 
                or "normalizer" or "claimcheck" or "dynamicrouter" or "routingslip"
                => ("Integration", "#22c55e", "üîÄ"),
            "httpstep" => ("HTTP", "#14b8a6", "üåê"),
            "llmcallstep" or "agentdecisionstep" => ("AI/Agents", "#a855f7", "ü§ñ"),
            "agentloopstep" or "toolcallstep" => ("AI/Agents", "#a855f7", "üß†"),
            "datamapstep" or "validatestep" or "schemavalidatestep" => ("Data", "#f97316", "üó∫"),
            "publisheventstep" or "subscribeeventstep" => ("Events", "#eab308", "‚ö°"),
            "humantaskstep" or "approvalstep" => ("Human Tasks", "#ec4899", "‚úÖ"),
            _ => ("Core", "#3b82f6", "‚¨°")
        };

        int edgeCounter = 0;
        void AddEdge(string source, string target, string? label = null)
        {
            edges.Add(new { id = $"edge_{++edgeCounter}", source, target, label });
        }

        (string entryId, string exitId) LayoutStep(StepDefinitionApiDto step, double x, double y)
        {
            var (cat, color, icon) = GetStepVisuals(step.Type);
            var nodeId = NextId();

            Dictionary<string, object?> ToNodeConfig(StepDefinitionApiDto s) =>
                s.Config?.ToDictionary(k => k.Key, k => (object?)k.Value) ?? new Dictionary<string, object?>();

            if (step.Type.Equals("Conditional", StringComparison.OrdinalIgnoreCase))
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = ToNodeConfig(step) });
                string lastId = nodeId;

                if (step.Then is not null)
                {
                    var (thenEntry, thenExit) = LayoutStep(step.Then, x + 200, y - 60);
                    AddEdge(nodeId, thenEntry, "then");
                    lastId = thenExit;
                }
                if (step.Else is not null)
                {
                    var (elseEntry, elseExit) = LayoutStep(step.Else, x + 200, y + 60);
                    AddEdge(nodeId, elseEntry, "else");
                    var mergeId = NextId();
                    nodes.Add(new { id = mergeId, type = "action", label = "‚Ü™ Merge", icon = "‚Ü™", category = "Core", color = "#6b7280", x = x + 400, y, config = new Dictionary<string, object?>() });
                    AddEdge(lastId, mergeId);
                    AddEdge(elseExit, mergeId);
                    return (nodeId, mergeId);
                }

                return (nodeId, lastId);
            }
            
            if (step.Type.Equals("Parallel", StringComparison.OrdinalIgnoreCase) && step.Steps is { Count: > 0 })
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = ToNodeConfig(step) });
                var joinId = NextId();
                double branchY = y - ((step.Steps.Count - 1) * 40.0);
                var branchExits = new List<string>();
                
                foreach (var child in step.Steps)
                {
                    var (childEntry, childExit) = LayoutStep(child, x + 200, branchY);
                    AddEdge(nodeId, childEntry);
                    branchExits.Add(childExit);
                    branchY += 80;
                }

                nodes.Add(new { id = joinId, type = "action", label = "‚Ü™ Join", icon = "‚Ü™", category = "Core", color = "#6b7280", x = x + 400, y, config = new Dictionary<string, object?>() });
                foreach (var exit in branchExits) AddEdge(exit, joinId);
                return (nodeId, joinId);
            }

            if ((step.Type.Equals("Retry", StringComparison.OrdinalIgnoreCase) 
                || step.Type.Equals("ForEach", StringComparison.OrdinalIgnoreCase)
                || step.Type.Equals("While", StringComparison.OrdinalIgnoreCase)
                || step.Type.Equals("DoWhile", StringComparison.OrdinalIgnoreCase)
                || step.Type.Equals("Saga", StringComparison.OrdinalIgnoreCase))
                && step.Steps is { Count: > 0 })
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = ToNodeConfig(step) });
                string lastChild = nodeId;
                double childX = x + 200;
                foreach (var child in step.Steps)
                {
                    var (childEntry, childExit) = LayoutStep(child, childX, y);
                    AddEdge(lastChild, childEntry);
                    lastChild = childExit;
                    childX += 200;
                }
                return (nodeId, lastChild);
            }

            if (step.Type.Equals("TryCatch", StringComparison.OrdinalIgnoreCase) && step.TryBody is { Count: > 0 })
            {
                nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = ToNodeConfig(step) });
                string lastTry = nodeId;
                double childX = x + 200;
                foreach (var child in step.TryBody)
                {
                    var (childEntry, childExit) = LayoutStep(child, childX, y);
                    AddEdge(lastTry, childEntry);
                    lastTry = childExit;
                    childX += 200;
                }
                if (step.FinallyBody is { Count: > 0 })
                {
                    foreach (var fin in step.FinallyBody)
                    {
                        var (finEntry, finExit) = LayoutStep(fin, childX, y + 80);
                        AddEdge(lastTry, finEntry);
                        lastTry = finExit;
                        childX += 200;
                    }
                }
                return (nodeId, lastTry);
            }

            nodes.Add(new { id = nodeId, type = step.Type, label = step.Name, icon, category = cat, color, x, y, config = ToNodeConfig(step) });
            return (nodeId, nodeId);
        }

        double currentX = 0;
        string? previousExit = null;

        foreach (var step in definition.Steps)
        {
            var (entryId, exitId) = LayoutStep(step, currentX, 100);
            if (previousExit is not null) AddEdge(previousExit, entryId);
            previousExit = exitId;
            
            currentX += step.Steps?.Count > 0 || step.Then is not null || step.TryBody?.Count > 0 
                ? 600 
                : 200;
        }

        await JS.InvokeVoidAsync("workflowEditor.setWorkflowDefinition", nodes.ToArray(), edges.ToArray());
        await JS.InvokeVoidAsync("workflowEditor.fitView");
        _activeBottomTab = "steps";
        _bottomPanelCollapsed = false;
        StateHasChanged();
        RefreshStepList();
    }

    private async Task HandleStepStatusChanged((string StepName, string Status) stepStatus)
    {
        try
        {
            await JS.InvokeVoidAsync("workflowEditor.updateNodeStatus", stepStatus.StepName, stepStatus.Status);
        }
        catch { }
    }

    private void HandleRunStatusChanged(string status)
    {
        _logEntries.Add($"[{DateTime.Now:HH:mm:ss}] Run status: {status}");
        if (status is "Completed" or "Failed" or "Cancelled")
        {
            _activeRunId = null;
        }
        StateHasChanged();
    }

    private static string GetLogClass(string entry) => entry switch
    {
        _ when entry.Contains("‚ùå") || entry.Contains("üí•") => "text-red-400",
        _ when entry.Contains("‚úÖ") || entry.Contains("üèÅ") => "text-green-400",
        _ when entry.Contains("‚è≥") => "text-yellow-400",
        _ => ""
    };

    private static string GetSeverityIcon(string severity) => severity switch
    {
        "Error" => "üî¥",
        "Warning" => "üü°",
        "Info" => "üîµ",
        _ => "‚ö™"
    };

    private static string GetSeverityClass(string severity) => severity switch
    {
        "Error" => "text-red-400",
        "Warning" => "text-yellow-400",
        "Info" => "text-blue-400",
        _ => "text-gray-400"
    };

    public async ValueTask DisposeAsync()
    {
        _dotNetRef?.Dispose();
        try { await Shortcuts.DisposeAsync(); } catch { }
        try { await JS.InvokeVoidAsync("workflowEditor.destroy"); } catch { }
    }
}
