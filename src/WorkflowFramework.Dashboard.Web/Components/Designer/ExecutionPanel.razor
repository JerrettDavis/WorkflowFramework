@using WorkflowFramework.Dashboard.Web.Services
@inject DashboardApiClient Api
@implements IAsyncDisposable

<div class="border-t border-gray-700 bg-gray-850" data-testid="execution-panel">
    <button @onclick="OnToggle"
            class="w-full flex items-center justify-between px-4 py-1.5 bg-gray-800 hover:bg-gray-750 text-xs text-gray-400">
        <span>
            Output
            @if (ActiveRunId is not null)
            {
                <span class="ml-2 text-yellow-400">‚óè @_runStatus</span>
            }
            @if (_hubClient?.State == Microsoft.AspNetCore.SignalR.Client.HubConnectionState.Connected)
            {
                <span class="ml-2 text-green-500" title="SignalR connected">‚ö°</span>
            }
        </span>
        <span>@(IsVisible ? "‚ñº" : "‚ñ≤")</span>
    </button>
    @if (IsVisible)
    {
        <div class="h-40 overflow-y-auto p-3 bg-gray-900 font-mono text-xs text-gray-300">
            @if (LogEntries.Count == 0)
            {
                <p class="text-gray-600">No output yet. Run a workflow to see results.</p>
            }
            else
            {
                @foreach (var entry in LogEntries)
                {
                    <div class="py-0.5 @GetLogClass(entry)">@entry</div>
                }
            }
        </div>
    }
</div>

@code {
    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public EventCallback OnToggle { get; set; }
    [Parameter] public List<string> LogEntries { get; set; } = [];
    [Parameter] public string? ActiveRunId { get; set; }
    [Parameter] public EventCallback<string> OnRunStatusChanged { get; set; }
    [Parameter] public EventCallback<(string StepName, string Status)> OnStepStatusChanged { get; set; }
    [Parameter] public string? SignalRHubUrl { get; set; }

    private string _runStatus = "";
    private ExecutionHubClient? _hubClient;
    private string? _subscribedRunId;

    protected override async Task OnParametersSetAsync()
    {
        if (ActiveRunId is not null && _subscribedRunId != ActiveRunId)
        {
            await SubscribeToRun(ActiveRunId);
        }
        else if (ActiveRunId is null && _subscribedRunId is not null)
        {
            await UnsubscribeFromRun();
        }
    }

    private async Task SubscribeToRun(string runId)
    {
        await UnsubscribeFromRun();

        var hubUrl = SignalRHubUrl ?? "https+http://dashboard-api/hubs/execution";
        _hubClient = new ExecutionHubClient(hubUrl);

        _hubClient.RunStarted += (rid, name) => InvokeAsync(() =>
        {
            _runStatus = "Running";
            LogEntries.Add($"[{DateTime.Now:HH:mm:ss}] ‚ñ∂ Run started: {name}");
            OnRunStatusChanged.InvokeAsync("Running");
            StateHasChanged();
        });

        _hubClient.StepStarted += (rid, step, idx) => InvokeAsync(() =>
        {
            LogEntries.Add($"[{DateTime.Now:HH:mm:ss}] ‚è≥ Step '{step}' started (#{idx})");
            OnStepStatusChanged.InvokeAsync((step, "Running"));
            StateHasChanged();
        });

        _hubClient.StepCompleted += (rid, step, status, ms, output) => InvokeAsync(() =>
        {
            LogEntries.Add($"[{DateTime.Now:HH:mm:ss}] ‚úÖ Step '{step}' {status} ({ms}ms)");
            if (output is not null) LogEntries.Add($"    ‚Üí {output}");
            OnStepStatusChanged.InvokeAsync((step, status));
            StateHasChanged();
        });

        _hubClient.StepFailed += (rid, step, err) => InvokeAsync(() =>
        {
            LogEntries.Add($"[{DateTime.Now:HH:mm:ss}] ‚ùå Step '{step}' failed: {err}");
            OnStepStatusChanged.InvokeAsync((step, "Failed"));
            StateHasChanged();
        });

        _hubClient.RunCompleted += (rid, status, ms) => InvokeAsync(() =>
        {
            _runStatus = status;
            LogEntries.Add($"[{DateTime.Now:HH:mm:ss}] üèÅ Run {status} ({ms}ms)");
            OnRunStatusChanged.InvokeAsync(status);
            StateHasChanged();
        });

        _hubClient.RunFailed += (rid, err) => InvokeAsync(() =>
        {
            _runStatus = "Failed";
            LogEntries.Add($"[{DateTime.Now:HH:mm:ss}] üí• Run failed: {err}");
            OnRunStatusChanged.InvokeAsync("Failed");
            StateHasChanged();
        });

        _hubClient.LogMessage += (rid, level, msg, ts) => InvokeAsync(() =>
        {
            LogEntries.Add($"[{ts:HH:mm:ss}] [{level}] {msg}");
            StateHasChanged();
        });

        try
        {
            await _hubClient.SubscribeToRunAsync(runId);
            _subscribedRunId = runId;
        }
        catch
        {
            // Fall back to polling if SignalR fails
            _ = PollRunStatusFallback(runId);
        }
    }

    private async Task UnsubscribeFromRun()
    {
        if (_hubClient is not null && _subscribedRunId is not null)
        {
            try { await _hubClient.UnsubscribeFromRunAsync(_subscribedRunId); } catch { }
            await _hubClient.DisposeAsync();
            _hubClient = null;
        }
        _subscribedRunId = null;
    }

    private async Task PollRunStatusFallback(string runId)
    {
        try
        {
            using var cts = new CancellationTokenSource();
            while (!cts.Token.IsCancellationRequested)
            {
                await Task.Delay(1000, cts.Token);
                var run = await Api.GetRunAsync(runId, cts.Token);
                if (run is null) break;

                _runStatus = run.Status;
                await OnRunStatusChanged.InvokeAsync(run.Status);
                await InvokeAsync(StateHasChanged);

                if (run.Status is "Completed" or "Failed" or "Cancelled") break;
            }
        }
        catch (OperationCanceledException) { }
        catch { }
    }

    private static string GetLogClass(string entry) => entry switch
    {
        _ when entry.Contains("‚ùå") || entry.Contains("üí•") => "text-red-400",
        _ when entry.Contains("‚úÖ") || entry.Contains("üèÅ") => "text-green-400",
        _ when entry.Contains("‚è≥") => "text-yellow-400",
        _ => ""
    };

    public async ValueTask DisposeAsync()
    {
        await UnsubscribeFromRun();
    }
}
